// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger/fabric/core/chaincode/lifecycle"
)

type ChaincodeLauncher struct {
	LaunchStub        func(ccid string) error
	launchMutex       sync.RWMutex
	launchArgsForCall []struct {
		ccid string
	}
	launchReturns struct {
		result1 error
	}
	launchReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(ccid string) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		ccid string
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	LaunchInProcStub        func(ccID string) <-chan struct{}
	launchInProcMutex       sync.RWMutex
	launchInProcArgsForCall []struct {
		ccID string
	}
	launchInProcReturns struct {
		result1 <-chan struct{}
	}
	launchInProcReturnsOnCall map[int]struct {
		result1 <-chan struct{}
	}
	StopInProcStub        func(ccID string) error
	stopInProcMutex       sync.RWMutex
	stopInProcArgsForCall []struct {
		ccID string
	}
	stopInProcReturns struct {
		result1 error
	}
	stopInProcReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ChaincodeLauncher) Launch(ccid string) error {
	fake.launchMutex.Lock()
	ret, specificReturn := fake.launchReturnsOnCall[len(fake.launchArgsForCall)]
	fake.launchArgsForCall = append(fake.launchArgsForCall, struct {
		ccid string
	}{ccid})
	fake.recordInvocation("Launch", []interface{}{ccid})
	fake.launchMutex.Unlock()
	if fake.LaunchStub != nil {
		return fake.LaunchStub(ccid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.launchReturns.result1
}

func (fake *ChaincodeLauncher) LaunchCallCount() int {
	fake.launchMutex.RLock()
	defer fake.launchMutex.RUnlock()
	return len(fake.launchArgsForCall)
}

func (fake *ChaincodeLauncher) LaunchArgsForCall(i int) string {
	fake.launchMutex.RLock()
	defer fake.launchMutex.RUnlock()
	return fake.launchArgsForCall[i].ccid
}

func (fake *ChaincodeLauncher) LaunchReturns(result1 error) {
	fake.LaunchStub = nil
	fake.launchReturns = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) LaunchReturnsOnCall(i int, result1 error) {
	fake.LaunchStub = nil
	if fake.launchReturnsOnCall == nil {
		fake.launchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.launchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) Stop(ccid string) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		ccid string
	}{ccid})
	fake.recordInvocation("Stop", []interface{}{ccid})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(ccid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopReturns.result1
}

func (fake *ChaincodeLauncher) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *ChaincodeLauncher) StopArgsForCall(i int) string {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].ccid
}

func (fake *ChaincodeLauncher) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) StopReturnsOnCall(i int, result1 error) {
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) LaunchInProc(ccID string) <-chan struct{} {
	fake.launchInProcMutex.Lock()
	ret, specificReturn := fake.launchInProcReturnsOnCall[len(fake.launchInProcArgsForCall)]
	fake.launchInProcArgsForCall = append(fake.launchInProcArgsForCall, struct {
		ccID string
	}{ccID})
	fake.recordInvocation("LaunchInProc", []interface{}{ccID})
	fake.launchInProcMutex.Unlock()
	if fake.LaunchInProcStub != nil {
		return fake.LaunchInProcStub(ccID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.launchInProcReturns.result1
}

func (fake *ChaincodeLauncher) LaunchInProcCallCount() int {
	fake.launchInProcMutex.RLock()
	defer fake.launchInProcMutex.RUnlock()
	return len(fake.launchInProcArgsForCall)
}

func (fake *ChaincodeLauncher) LaunchInProcArgsForCall(i int) string {
	fake.launchInProcMutex.RLock()
	defer fake.launchInProcMutex.RUnlock()
	return fake.launchInProcArgsForCall[i].ccID
}

func (fake *ChaincodeLauncher) LaunchInProcReturns(result1 <-chan struct{}) {
	fake.LaunchInProcStub = nil
	fake.launchInProcReturns = struct {
		result1 <-chan struct{}
	}{result1}
}

func (fake *ChaincodeLauncher) LaunchInProcReturnsOnCall(i int, result1 <-chan struct{}) {
	fake.LaunchInProcStub = nil
	if fake.launchInProcReturnsOnCall == nil {
		fake.launchInProcReturnsOnCall = make(map[int]struct {
			result1 <-chan struct{}
		})
	}
	fake.launchInProcReturnsOnCall[i] = struct {
		result1 <-chan struct{}
	}{result1}
}

func (fake *ChaincodeLauncher) StopInProc(ccID string) error {
	fake.stopInProcMutex.Lock()
	ret, specificReturn := fake.stopInProcReturnsOnCall[len(fake.stopInProcArgsForCall)]
	fake.stopInProcArgsForCall = append(fake.stopInProcArgsForCall, struct {
		ccID string
	}{ccID})
	fake.recordInvocation("StopInProc", []interface{}{ccID})
	fake.stopInProcMutex.Unlock()
	if fake.StopInProcStub != nil {
		return fake.StopInProcStub(ccID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopInProcReturns.result1
}

func (fake *ChaincodeLauncher) StopInProcCallCount() int {
	fake.stopInProcMutex.RLock()
	defer fake.stopInProcMutex.RUnlock()
	return len(fake.stopInProcArgsForCall)
}

func (fake *ChaincodeLauncher) StopInProcArgsForCall(i int) string {
	fake.stopInProcMutex.RLock()
	defer fake.stopInProcMutex.RUnlock()
	return fake.stopInProcArgsForCall[i].ccID
}

func (fake *ChaincodeLauncher) StopInProcReturns(result1 error) {
	fake.StopInProcStub = nil
	fake.stopInProcReturns = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) StopInProcReturnsOnCall(i int, result1 error) {
	fake.StopInProcStub = nil
	if fake.stopInProcReturnsOnCall == nil {
		fake.stopInProcReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopInProcReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ChaincodeLauncher) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.launchMutex.RLock()
	defer fake.launchMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.launchInProcMutex.RLock()
	defer fake.launchInProcMutex.RUnlock()
	fake.stopInProcMutex.RLock()
	defer fake.stopInProcMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ChaincodeLauncher) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ lifecycle.ChaincodeLauncher = new(ChaincodeLauncher)
