// Code generated by counterfeiter. DO NOT EDIT.
package idstore

import (
	"sync"

	"github.com/hyperledger/fabric-protos-go/common"
	"github.com/hyperledger/fabric/core/ledger/kvledger/msgs"
	"github.com/hyperledger/fabric/extensions/storage/api"
)

type MockIDStore struct {
	SetUnderConstructionFlagStub        func(string) error
	setUnderConstructionFlagMutex       sync.RWMutex
	setUnderConstructionFlagArgsForCall []struct {
		arg1 string
	}
	setUnderConstructionFlagReturns struct {
		result1 error
	}
	setUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetUnderConstructionFlagStub        func() error
	unsetUnderConstructionFlagMutex       sync.RWMutex
	unsetUnderConstructionFlagArgsForCall []struct{}
	unsetUnderConstructionFlagReturns     struct {
		result1 error
	}
	unsetUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 error
	}
	GetUnderConstructionFlagStub        func() (string, error)
	getUnderConstructionFlagMutex       sync.RWMutex
	getUnderConstructionFlagArgsForCall []struct{}
	getUnderConstructionFlagReturns     struct {
		result1 string
		result2 error
	}
	getUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateLedgerIDStub        func(ledgerID string, gb *common.Block) error
	createLedgerIDMutex       sync.RWMutex
	createLedgerIDArgsForCall []struct {
		ledgerID string
		gb       *common.Block
	}
	createLedgerIDReturns struct {
		result1 error
	}
	createLedgerIDReturnsOnCall map[int]struct {
		result1 error
	}
	LedgerIDExistsStub        func(ledgerID string) (bool, error)
	ledgerIDExistsMutex       sync.RWMutex
	ledgerIDExistsArgsForCall []struct {
		ledgerID string
	}
	ledgerIDExistsReturns struct {
		result1 bool
		result2 error
	}
	ledgerIDExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LedgerIDActiveStub        func(ledgerID string) (active bool, exists bool, err error)
	ledgerIDActiveMutex       sync.RWMutex
	ledgerIDActiveArgsForCall []struct {
		ledgerID string
	}
	ledgerIDActiveReturns struct {
		result1 bool
		result2 bool
		result3 error
	}
	ledgerIDActiveReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 error
	}
	GetActiveLedgerIDsStub        func() ([]string, error)
	getActiveLedgerIDsMutex       sync.RWMutex
	getActiveLedgerIDsArgsForCall []struct{}
	getActiveLedgerIDsReturns     struct {
		result1 []string
		result2 error
	}
	getActiveLedgerIDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	UpdateLedgerStatusStub        func(ledgerID string, newStatus msgs.Status) error
	updateLedgerStatusMutex       sync.RWMutex
	updateLedgerStatusArgsForCall []struct {
		ledgerID  string
		newStatus msgs.Status
	}
	updateLedgerStatusReturns struct {
		result1 error
	}
	updateLedgerStatusReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeFormatStub        func() error
	upgradeFormatMutex       sync.RWMutex
	upgradeFormatArgsForCall []struct{}
	upgradeFormatReturns     struct {
		result1 error
	}
	upgradeFormatReturnsOnCall map[int]struct {
		result1 error
	}
	CheckUpgradeEligibilityStub        func() (bool, error)
	checkUpgradeEligibilityMutex       sync.RWMutex
	checkUpgradeEligibilityArgsForCall []struct{}
	checkUpgradeEligibilityReturns     struct {
		result1 bool
		result2 error
	}
	checkUpgradeEligibilityReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CloseStub                  func()
	closeMutex                 sync.RWMutex
	closeArgsForCall           []struct{}
	EncodeLedgerKeyStub        func(ledgerID string, prefix []byte) []byte
	encodeLedgerKeyMutex       sync.RWMutex
	encodeLedgerKeyArgsForCall []struct {
		ledgerID string
		prefix   []byte
	}
	encodeLedgerKeyReturns struct {
		result1 []byte
	}
	encodeLedgerKeyReturnsOnCall map[int]struct {
		result1 []byte
	}
	DecodeLedgerIDStub        func(key []byte, prefix []byte) string
	decodeLedgerIDMutex       sync.RWMutex
	decodeLedgerIDArgsForCall []struct {
		key    []byte
		prefix []byte
	}
	decodeLedgerIDReturns struct {
		result1 string
	}
	decodeLedgerIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetStub        func(key []byte) ([]byte, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		key []byte
	}
	getReturns struct {
		result1 []byte
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	PutStub        func(key []byte, value []byte) error
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		key   []byte
		value []byte
	}
	putReturns struct {
		result1 error
	}
	putReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *MockIDStore) SetUnderConstructionFlag(arg1 string) error {
	fake.setUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.setUnderConstructionFlagReturnsOnCall[len(fake.setUnderConstructionFlagArgsForCall)]
	fake.setUnderConstructionFlagArgsForCall = append(fake.setUnderConstructionFlagArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetUnderConstructionFlag", []interface{}{arg1})
	fake.setUnderConstructionFlagMutex.Unlock()
	if fake.SetUnderConstructionFlagStub != nil {
		return fake.SetUnderConstructionFlagStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setUnderConstructionFlagReturns.result1
}

func (fake *MockIDStore) SetUnderConstructionFlagCallCount() int {
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	return len(fake.setUnderConstructionFlagArgsForCall)
}

func (fake *MockIDStore) SetUnderConstructionFlagArgsForCall(i int) string {
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	return fake.setUnderConstructionFlagArgsForCall[i].arg1
}

func (fake *MockIDStore) SetUnderConstructionFlagReturns(result1 error) {
	fake.SetUnderConstructionFlagStub = nil
	fake.setUnderConstructionFlagReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) SetUnderConstructionFlagReturnsOnCall(i int, result1 error) {
	fake.SetUnderConstructionFlagStub = nil
	if fake.setUnderConstructionFlagReturnsOnCall == nil {
		fake.setUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) UnsetUnderConstructionFlag() error {
	fake.unsetUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.unsetUnderConstructionFlagReturnsOnCall[len(fake.unsetUnderConstructionFlagArgsForCall)]
	fake.unsetUnderConstructionFlagArgsForCall = append(fake.unsetUnderConstructionFlagArgsForCall, struct{}{})
	fake.recordInvocation("UnsetUnderConstructionFlag", []interface{}{})
	fake.unsetUnderConstructionFlagMutex.Unlock()
	if fake.UnsetUnderConstructionFlagStub != nil {
		return fake.UnsetUnderConstructionFlagStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unsetUnderConstructionFlagReturns.result1
}

func (fake *MockIDStore) UnsetUnderConstructionFlagCallCount() int {
	fake.unsetUnderConstructionFlagMutex.RLock()
	defer fake.unsetUnderConstructionFlagMutex.RUnlock()
	return len(fake.unsetUnderConstructionFlagArgsForCall)
}

func (fake *MockIDStore) UnsetUnderConstructionFlagReturns(result1 error) {
	fake.UnsetUnderConstructionFlagStub = nil
	fake.unsetUnderConstructionFlagReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) UnsetUnderConstructionFlagReturnsOnCall(i int, result1 error) {
	fake.UnsetUnderConstructionFlagStub = nil
	if fake.unsetUnderConstructionFlagReturnsOnCall == nil {
		fake.unsetUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) GetUnderConstructionFlag() (string, error) {
	fake.getUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.getUnderConstructionFlagReturnsOnCall[len(fake.getUnderConstructionFlagArgsForCall)]
	fake.getUnderConstructionFlagArgsForCall = append(fake.getUnderConstructionFlagArgsForCall, struct{}{})
	fake.recordInvocation("GetUnderConstructionFlag", []interface{}{})
	fake.getUnderConstructionFlagMutex.Unlock()
	if fake.GetUnderConstructionFlagStub != nil {
		return fake.GetUnderConstructionFlagStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getUnderConstructionFlagReturns.result1, fake.getUnderConstructionFlagReturns.result2
}

func (fake *MockIDStore) GetUnderConstructionFlagCallCount() int {
	fake.getUnderConstructionFlagMutex.RLock()
	defer fake.getUnderConstructionFlagMutex.RUnlock()
	return len(fake.getUnderConstructionFlagArgsForCall)
}

func (fake *MockIDStore) GetUnderConstructionFlagReturns(result1 string, result2 error) {
	fake.GetUnderConstructionFlagStub = nil
	fake.getUnderConstructionFlagReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) GetUnderConstructionFlagReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetUnderConstructionFlagStub = nil
	if fake.getUnderConstructionFlagReturnsOnCall == nil {
		fake.getUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) CreateLedgerID(ledgerID string, gb *common.Block) error {
	fake.createLedgerIDMutex.Lock()
	ret, specificReturn := fake.createLedgerIDReturnsOnCall[len(fake.createLedgerIDArgsForCall)]
	fake.createLedgerIDArgsForCall = append(fake.createLedgerIDArgsForCall, struct {
		ledgerID string
		gb       *common.Block
	}{ledgerID, gb})
	fake.recordInvocation("CreateLedgerID", []interface{}{ledgerID, gb})
	fake.createLedgerIDMutex.Unlock()
	if fake.CreateLedgerIDStub != nil {
		return fake.CreateLedgerIDStub(ledgerID, gb)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createLedgerIDReturns.result1
}

func (fake *MockIDStore) CreateLedgerIDCallCount() int {
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	return len(fake.createLedgerIDArgsForCall)
}

func (fake *MockIDStore) CreateLedgerIDArgsForCall(i int) (string, *common.Block) {
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	return fake.createLedgerIDArgsForCall[i].ledgerID, fake.createLedgerIDArgsForCall[i].gb
}

func (fake *MockIDStore) CreateLedgerIDReturns(result1 error) {
	fake.CreateLedgerIDStub = nil
	fake.createLedgerIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) CreateLedgerIDReturnsOnCall(i int, result1 error) {
	fake.CreateLedgerIDStub = nil
	if fake.createLedgerIDReturnsOnCall == nil {
		fake.createLedgerIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createLedgerIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) LedgerIDExists(ledgerID string) (bool, error) {
	fake.ledgerIDExistsMutex.Lock()
	ret, specificReturn := fake.ledgerIDExistsReturnsOnCall[len(fake.ledgerIDExistsArgsForCall)]
	fake.ledgerIDExistsArgsForCall = append(fake.ledgerIDExistsArgsForCall, struct {
		ledgerID string
	}{ledgerID})
	fake.recordInvocation("LedgerIDExists", []interface{}{ledgerID})
	fake.ledgerIDExistsMutex.Unlock()
	if fake.LedgerIDExistsStub != nil {
		return fake.LedgerIDExistsStub(ledgerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ledgerIDExistsReturns.result1, fake.ledgerIDExistsReturns.result2
}

func (fake *MockIDStore) LedgerIDExistsCallCount() int {
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	return len(fake.ledgerIDExistsArgsForCall)
}

func (fake *MockIDStore) LedgerIDExistsArgsForCall(i int) string {
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	return fake.ledgerIDExistsArgsForCall[i].ledgerID
}

func (fake *MockIDStore) LedgerIDExistsReturns(result1 bool, result2 error) {
	fake.LedgerIDExistsStub = nil
	fake.ledgerIDExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) LedgerIDExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.LedgerIDExistsStub = nil
	if fake.ledgerIDExistsReturnsOnCall == nil {
		fake.ledgerIDExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.ledgerIDExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) LedgerIDActive(ledgerID string) (active bool, exists bool, err error) {
	fake.ledgerIDActiveMutex.Lock()
	ret, specificReturn := fake.ledgerIDActiveReturnsOnCall[len(fake.ledgerIDActiveArgsForCall)]
	fake.ledgerIDActiveArgsForCall = append(fake.ledgerIDActiveArgsForCall, struct {
		ledgerID string
	}{ledgerID})
	fake.recordInvocation("LedgerIDActive", []interface{}{ledgerID})
	fake.ledgerIDActiveMutex.Unlock()
	if fake.LedgerIDActiveStub != nil {
		return fake.LedgerIDActiveStub(ledgerID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.ledgerIDActiveReturns.result1, fake.ledgerIDActiveReturns.result2, fake.ledgerIDActiveReturns.result3
}

func (fake *MockIDStore) LedgerIDActiveCallCount() int {
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	return len(fake.ledgerIDActiveArgsForCall)
}

func (fake *MockIDStore) LedgerIDActiveArgsForCall(i int) string {
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	return fake.ledgerIDActiveArgsForCall[i].ledgerID
}

func (fake *MockIDStore) LedgerIDActiveReturns(result1 bool, result2 bool, result3 error) {
	fake.LedgerIDActiveStub = nil
	fake.ledgerIDActiveReturns = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *MockIDStore) LedgerIDActiveReturnsOnCall(i int, result1 bool, result2 bool, result3 error) {
	fake.LedgerIDActiveStub = nil
	if fake.ledgerIDActiveReturnsOnCall == nil {
		fake.ledgerIDActiveReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 error
		})
	}
	fake.ledgerIDActiveReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *MockIDStore) GetActiveLedgerIDs() ([]string, error) {
	fake.getActiveLedgerIDsMutex.Lock()
	ret, specificReturn := fake.getActiveLedgerIDsReturnsOnCall[len(fake.getActiveLedgerIDsArgsForCall)]
	fake.getActiveLedgerIDsArgsForCall = append(fake.getActiveLedgerIDsArgsForCall, struct{}{})
	fake.recordInvocation("GetActiveLedgerIDs", []interface{}{})
	fake.getActiveLedgerIDsMutex.Unlock()
	if fake.GetActiveLedgerIDsStub != nil {
		return fake.GetActiveLedgerIDsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getActiveLedgerIDsReturns.result1, fake.getActiveLedgerIDsReturns.result2
}

func (fake *MockIDStore) GetActiveLedgerIDsCallCount() int {
	fake.getActiveLedgerIDsMutex.RLock()
	defer fake.getActiveLedgerIDsMutex.RUnlock()
	return len(fake.getActiveLedgerIDsArgsForCall)
}

func (fake *MockIDStore) GetActiveLedgerIDsReturns(result1 []string, result2 error) {
	fake.GetActiveLedgerIDsStub = nil
	fake.getActiveLedgerIDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) GetActiveLedgerIDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetActiveLedgerIDsStub = nil
	if fake.getActiveLedgerIDsReturnsOnCall == nil {
		fake.getActiveLedgerIDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getActiveLedgerIDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) UpdateLedgerStatus(ledgerID string, newStatus msgs.Status) error {
	fake.updateLedgerStatusMutex.Lock()
	ret, specificReturn := fake.updateLedgerStatusReturnsOnCall[len(fake.updateLedgerStatusArgsForCall)]
	fake.updateLedgerStatusArgsForCall = append(fake.updateLedgerStatusArgsForCall, struct {
		ledgerID  string
		newStatus msgs.Status
	}{ledgerID, newStatus})
	fake.recordInvocation("UpdateLedgerStatus", []interface{}{ledgerID, newStatus})
	fake.updateLedgerStatusMutex.Unlock()
	if fake.UpdateLedgerStatusStub != nil {
		return fake.UpdateLedgerStatusStub(ledgerID, newStatus)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateLedgerStatusReturns.result1
}

func (fake *MockIDStore) UpdateLedgerStatusCallCount() int {
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	return len(fake.updateLedgerStatusArgsForCall)
}

func (fake *MockIDStore) UpdateLedgerStatusArgsForCall(i int) (string, msgs.Status) {
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	return fake.updateLedgerStatusArgsForCall[i].ledgerID, fake.updateLedgerStatusArgsForCall[i].newStatus
}

func (fake *MockIDStore) UpdateLedgerStatusReturns(result1 error) {
	fake.UpdateLedgerStatusStub = nil
	fake.updateLedgerStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) UpdateLedgerStatusReturnsOnCall(i int, result1 error) {
	fake.UpdateLedgerStatusStub = nil
	if fake.updateLedgerStatusReturnsOnCall == nil {
		fake.updateLedgerStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLedgerStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) UpgradeFormat() error {
	fake.upgradeFormatMutex.Lock()
	ret, specificReturn := fake.upgradeFormatReturnsOnCall[len(fake.upgradeFormatArgsForCall)]
	fake.upgradeFormatArgsForCall = append(fake.upgradeFormatArgsForCall, struct{}{})
	fake.recordInvocation("UpgradeFormat", []interface{}{})
	fake.upgradeFormatMutex.Unlock()
	if fake.UpgradeFormatStub != nil {
		return fake.UpgradeFormatStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeFormatReturns.result1
}

func (fake *MockIDStore) UpgradeFormatCallCount() int {
	fake.upgradeFormatMutex.RLock()
	defer fake.upgradeFormatMutex.RUnlock()
	return len(fake.upgradeFormatArgsForCall)
}

func (fake *MockIDStore) UpgradeFormatReturns(result1 error) {
	fake.UpgradeFormatStub = nil
	fake.upgradeFormatReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) UpgradeFormatReturnsOnCall(i int, result1 error) {
	fake.UpgradeFormatStub = nil
	if fake.upgradeFormatReturnsOnCall == nil {
		fake.upgradeFormatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeFormatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) CheckUpgradeEligibility() (bool, error) {
	fake.checkUpgradeEligibilityMutex.Lock()
	ret, specificReturn := fake.checkUpgradeEligibilityReturnsOnCall[len(fake.checkUpgradeEligibilityArgsForCall)]
	fake.checkUpgradeEligibilityArgsForCall = append(fake.checkUpgradeEligibilityArgsForCall, struct{}{})
	fake.recordInvocation("CheckUpgradeEligibility", []interface{}{})
	fake.checkUpgradeEligibilityMutex.Unlock()
	if fake.CheckUpgradeEligibilityStub != nil {
		return fake.CheckUpgradeEligibilityStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkUpgradeEligibilityReturns.result1, fake.checkUpgradeEligibilityReturns.result2
}

func (fake *MockIDStore) CheckUpgradeEligibilityCallCount() int {
	fake.checkUpgradeEligibilityMutex.RLock()
	defer fake.checkUpgradeEligibilityMutex.RUnlock()
	return len(fake.checkUpgradeEligibilityArgsForCall)
}

func (fake *MockIDStore) CheckUpgradeEligibilityReturns(result1 bool, result2 error) {
	fake.CheckUpgradeEligibilityStub = nil
	fake.checkUpgradeEligibilityReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) CheckUpgradeEligibilityReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckUpgradeEligibilityStub = nil
	if fake.checkUpgradeEligibilityReturnsOnCall == nil {
		fake.checkUpgradeEligibilityReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkUpgradeEligibilityReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *MockIDStore) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *MockIDStore) EncodeLedgerKey(ledgerID string, prefix []byte) []byte {
	var prefixCopy []byte
	if prefix != nil {
		prefixCopy = make([]byte, len(prefix))
		copy(prefixCopy, prefix)
	}
	fake.encodeLedgerKeyMutex.Lock()
	ret, specificReturn := fake.encodeLedgerKeyReturnsOnCall[len(fake.encodeLedgerKeyArgsForCall)]
	fake.encodeLedgerKeyArgsForCall = append(fake.encodeLedgerKeyArgsForCall, struct {
		ledgerID string
		prefix   []byte
	}{ledgerID, prefixCopy})
	fake.recordInvocation("EncodeLedgerKey", []interface{}{ledgerID, prefixCopy})
	fake.encodeLedgerKeyMutex.Unlock()
	if fake.EncodeLedgerKeyStub != nil {
		return fake.EncodeLedgerKeyStub(ledgerID, prefix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.encodeLedgerKeyReturns.result1
}

func (fake *MockIDStore) EncodeLedgerKeyCallCount() int {
	fake.encodeLedgerKeyMutex.RLock()
	defer fake.encodeLedgerKeyMutex.RUnlock()
	return len(fake.encodeLedgerKeyArgsForCall)
}

func (fake *MockIDStore) EncodeLedgerKeyArgsForCall(i int) (string, []byte) {
	fake.encodeLedgerKeyMutex.RLock()
	defer fake.encodeLedgerKeyMutex.RUnlock()
	return fake.encodeLedgerKeyArgsForCall[i].ledgerID, fake.encodeLedgerKeyArgsForCall[i].prefix
}

func (fake *MockIDStore) EncodeLedgerKeyReturns(result1 []byte) {
	fake.EncodeLedgerKeyStub = nil
	fake.encodeLedgerKeyReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *MockIDStore) EncodeLedgerKeyReturnsOnCall(i int, result1 []byte) {
	fake.EncodeLedgerKeyStub = nil
	if fake.encodeLedgerKeyReturnsOnCall == nil {
		fake.encodeLedgerKeyReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.encodeLedgerKeyReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *MockIDStore) DecodeLedgerID(key []byte, prefix []byte) string {
	var keyCopy []byte
	if key != nil {
		keyCopy = make([]byte, len(key))
		copy(keyCopy, key)
	}
	var prefixCopy []byte
	if prefix != nil {
		prefixCopy = make([]byte, len(prefix))
		copy(prefixCopy, prefix)
	}
	fake.decodeLedgerIDMutex.Lock()
	ret, specificReturn := fake.decodeLedgerIDReturnsOnCall[len(fake.decodeLedgerIDArgsForCall)]
	fake.decodeLedgerIDArgsForCall = append(fake.decodeLedgerIDArgsForCall, struct {
		key    []byte
		prefix []byte
	}{keyCopy, prefixCopy})
	fake.recordInvocation("DecodeLedgerID", []interface{}{keyCopy, prefixCopy})
	fake.decodeLedgerIDMutex.Unlock()
	if fake.DecodeLedgerIDStub != nil {
		return fake.DecodeLedgerIDStub(key, prefix)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.decodeLedgerIDReturns.result1
}

func (fake *MockIDStore) DecodeLedgerIDCallCount() int {
	fake.decodeLedgerIDMutex.RLock()
	defer fake.decodeLedgerIDMutex.RUnlock()
	return len(fake.decodeLedgerIDArgsForCall)
}

func (fake *MockIDStore) DecodeLedgerIDArgsForCall(i int) ([]byte, []byte) {
	fake.decodeLedgerIDMutex.RLock()
	defer fake.decodeLedgerIDMutex.RUnlock()
	return fake.decodeLedgerIDArgsForCall[i].key, fake.decodeLedgerIDArgsForCall[i].prefix
}

func (fake *MockIDStore) DecodeLedgerIDReturns(result1 string) {
	fake.DecodeLedgerIDStub = nil
	fake.decodeLedgerIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *MockIDStore) DecodeLedgerIDReturnsOnCall(i int, result1 string) {
	fake.DecodeLedgerIDStub = nil
	if fake.decodeLedgerIDReturnsOnCall == nil {
		fake.decodeLedgerIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.decodeLedgerIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *MockIDStore) Get(key []byte) ([]byte, error) {
	var keyCopy []byte
	if key != nil {
		keyCopy = make([]byte, len(key))
		copy(keyCopy, key)
	}
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		key []byte
	}{keyCopy})
	fake.recordInvocation("Get", []interface{}{keyCopy})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *MockIDStore) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *MockIDStore) GetArgsForCall(i int) []byte {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].key
}

func (fake *MockIDStore) GetReturns(result1 []byte, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) GetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockIDStore) Put(key []byte, value []byte) error {
	var keyCopy []byte
	if key != nil {
		keyCopy = make([]byte, len(key))
		copy(keyCopy, key)
	}
	var valueCopy []byte
	if value != nil {
		valueCopy = make([]byte, len(value))
		copy(valueCopy, value)
	}
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		key   []byte
		value []byte
	}{keyCopy, valueCopy})
	fake.recordInvocation("Put", []interface{}{keyCopy, valueCopy})
	fake.putMutex.Unlock()
	if fake.PutStub != nil {
		return fake.PutStub(key, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putReturns.result1
}

func (fake *MockIDStore) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *MockIDStore) PutArgsForCall(i int) ([]byte, []byte) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return fake.putArgsForCall[i].key, fake.putArgsForCall[i].value
}

func (fake *MockIDStore) PutReturns(result1 error) {
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) PutReturnsOnCall(i int, result1 error) {
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockIDStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	fake.unsetUnderConstructionFlagMutex.RLock()
	defer fake.unsetUnderConstructionFlagMutex.RUnlock()
	fake.getUnderConstructionFlagMutex.RLock()
	defer fake.getUnderConstructionFlagMutex.RUnlock()
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	fake.getActiveLedgerIDsMutex.RLock()
	defer fake.getActiveLedgerIDsMutex.RUnlock()
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	fake.upgradeFormatMutex.RLock()
	defer fake.upgradeFormatMutex.RUnlock()
	fake.checkUpgradeEligibilityMutex.RLock()
	defer fake.checkUpgradeEligibilityMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.encodeLedgerKeyMutex.RLock()
	defer fake.encodeLedgerKeyMutex.RUnlock()
	fake.decodeLedgerIDMutex.RLock()
	defer fake.decodeLedgerIDMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *MockIDStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.IDStore = new(MockIDStore)
